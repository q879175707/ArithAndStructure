红-黑树特征
	两个特征，一个简单，一个复杂
	节点都有颜色
	在插入和删除的过程中，要遵循保持这些颜色的不同排列的规则。
	
带颜色的节点
	在RBTree中，每一个节点或者是黑色的或者是红色的。也可以是任意的两种颜色。颜色是一种标记。
红-黑规则
	当插入（或者删除）一个新节点时，必须要遵循一些规则，它们被称为红-黑规则。如果遵循这些规则，
树就是平衡的。
	1.每一个节点不是红色的就是黑色的。
	2.根总是黑色的。
	3.如果节点是红色的，则它的子节点必须是黑色的。
	4.从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。
	空子节点指的是 非叶子节点可以接子节点的位置。就是有一个子节点的节点，另一个子节点是空的位置。
	从根到叶节点的路径上的黑色节点的数目称为黑色高度。规则4的另一种称述方法是所有从根到叶节点路
径上的黑色高度必须相同。

修正违规的情况
	假设看到颜色的规则被违反了，有两个可能的修正措施：
	改变节点的颜色
	执行旋转操作。
	
旋转
	为了平衡一些树，需要重新手动地排列节点。例如，如果所有的节点都在根的左侧，就需要把一些节点移到
右侧。这使用旋转来实现。旋转必须一次做两件事：
	1.使一些节点上升，一些节点下降，帮助树平衡。
	2.保证不破坏二叉搜索树的特征。
	二叉搜索树的特征，即任何节点的左子节点以及其子树的关键字值都小于该节点，而它的右子节点及其子树
的关键字值都大于或者等于它。
	
	节点自身是不会旋转的；旋转改变的只是节点之间的关系。选择一个节点作为旋转的“顶端”(top)。如果
做一次右旋，这个“顶端”节点将会向下和向右移动到它右子节点的位置。它的左子节点将会上移到它原来的位置上。

注意子节点
	必须要确保，如果做右旋，顶端节点必须有一个左子节点。否则，将没有节点旋转到顶端节点原来所在的位置。
类似的，如果做左旋，顶端节点必须有一个右子节点。
例如
				50										25		
		25				75      ------》50右旋 	12				50
	12		37												37		75
	节点12跟着节点25上升，节点50跟着节点75下降。节点37虽然是25的右子节点，但是它断开了和节点25的连接，
并且取代25称为50的左子节点。
	节点37称为顶端节点50的内侧子孙（节点12是外侧子孙节点）。对内侧子孙节点而言，如果它是上移节点（在右旋
中是顶端节点的左子节点）的子节点，它总是要断开和父节点的连接并且重新连接到它以前的祖父节点上。

使用X、P、G表示关联的节点。
.X是一个特殊的节点
.P是X的父
.G是X的祖父节点（P的父节点）
顺着树向下查找插入点时，只要发现一个黑色节点有两个红色的子节点就执行一次颜色变换，因为插入的节点X是红色的。只用一次
或者两次旋转就可以解决冲突，继续向下查找插入点，并且插入行的数据项。
	完成新节点X的插入后，如果P是黑色的，只需要连接这个新的红色节点。如果P是红色的，则有两种可能性：X是G的外侧子
孙节点，或者X是G的内侧子孙节点。需要两次改变节点颜色。如果X是外侧节点，则执行一次旋转，如果X是内侧节点，则执行两次
旋转。

深入讨论细节问题。讨论分为三个部分，按复杂程序排列，分别是：
1.在下行路途中的颜色变换。
2.插入节点之后的旋转。
3.在向下路途上的旋转。

在下行路途中的颜色变换。
	RBTree插入例程开始时所做的事和普通的二叉搜索树所做的基本一样：沿着从根朝插入点位置走，在每一个节点处通过比较节点
的关键字相对大小来绝定向左走还是向右走。
	但是，在RBTree中，找到插入点更复杂，因为有颜色变换和旋转。
	假设插入例程顺着树向下执行，在每一个节点处向左或者向右走，查找插入新节点的位置。为了不违反颜色规则，在必要的时候需要
进行颜色变换。下面是规则：每当查找例程遇到一个有两个红色子节点的黑色节点时，它必须把子节点变为黑色，而把父节点变为红色（除
非父节点为根节点，根总是黑色的）。这样做黑色高度不改变。尽管不会违背规则4，但是可能会违背规则3（一个节点和它的父节点不能都
是红色的）。如果P的父是黑色的，则P由黑色变为红色时不会有任何问题。但是，如果P的父节点是红色的，那么在P的颜色变化之后，就
会有两个红色节点相连接了。
	这个问题需要在继续向下沿着路径插入新节点之前解决。通过旋转修正这个情况。
	最后，插入节点。
插入节点之后的旋转
	新数据项的插入可能会违背红-黑规则。因此，在插入之后，必须要检测是否违背规则，并采取相应的措施。
	新插入的称为X的节点总是红色的。X可能插入到相对P和G不同的位置上。
	
		G	|		G	|	G		|	G
	P		|	P		|		P	|		P
X			|		X	|	X		|			X
  外侧子孙			内侧子孙		内侧子孙		外侧子孙

	如果节点X在P的一侧与P在G的一侧相同，则X就是一个外侧子孙节点。与之相反X是一个内侧子孙节点。
	
	节点只以三种方式排列。每种可能性都必须由一种不同的方法处理，以保证红-黑树的正确性以及由此而生成的平衡树。X总是红色的。
	1.P是黑色的。
	2.P是红色的，X是G的一个外侧子孙节点。
	3.P是红色的，X是G的一个内侧子孙节点。
	
	可能性1：P是黑色的
	如果P是黑色的，就什么事也不做。刚刚插入的节点总是红色的。如果它的父节点是黑色的，则没有红色节点连接的冲突并且也不会增加
黑色节点的数目。因此不会违背规则。插入完成了。

	可能性2：P是红色的，X是G的一个外侧子孙节点
	如果P是红色的并且X是G的一个外侧子孙节点，则需要一次旋转和一些颜色的变化。
						50(Black)							50(black)
					25(b)		75(b)					12(b)		75(b)	
				12(red)								6(red)	25(red)
			6(red)
	这种情况下，可以采取三个步骤使树重新符合红-黑规则。下面就是三个步骤：
	1.改变X的祖父节点G(25)的颜色。
	2.改变X的父节点P(12)的颜色。
	3.以X的祖父节点G(25)为顶旋转，右旋。	
	
	可能性3：P是红色的，X是G的一个内侧子孙节点
	如果P是红色的，X是内侧子孙节点，则需要两次旋转和一些颜色的改变。
			50(b)							50(b)						50(b)
		25(b)		75(b)				25(r)		75(b)			18(b)		75(b)
	12(red)							18(b)						12(red)	25(r)
		18(red)					12(r)
								X由内侧子孙节点变为外侧节点			 以祖父节点（相对以前的X来说）为顶右旋
	同时还得重新为节点着色。在做任何旋转之前来做这件事情。步骤如下：
	1.改变X的祖父节点的颜色。（本例为25）
	2.改变X的颜色。
	3.用X的父节点P作为顶旋转，向X上升的方向旋转（本例左旋）。
	4.再以X的祖父节点(25)为顶旋转，向X上升的方向旋转（本例右旋）。
	
	旋转和改变颜色使树恢复为正确的红-黑树，也使树平衡（尽可能的）。它也有一个类似的情况，即P是G的右子节点而不是左子节点。
	
在下行路途中的旋转
	在向下的路径上有两种旋转的可能性，分别对应前面描述的在插入阶段的可能性2和可能性3.违背规则的节点可能是一个外侧子孙节点
，也可能是一个内侧子孙节点（对应可能性1的情况，不需要做任何的操作）
	外侧子孙节点
	首先看一个例子，例子中违背规则的节点是一个外侧子孙节点。“违背规则的节点”是指在造成红-红冲突的父-子节点对中的子节点。
	从节点50开始建一棵树，插入如下节点：25 75 12 37 6 18,中间插入需要颜色转换。现在插入值为3的节点。
			50(b)
		25(r)		75(b)
	12(r)	37(b)
6(b)	18(b)