不论哈希表中有多少数据，插入和删除只需要接近常量的时间：即O(1)的时间级。
哈希表不仅速度快，编程实现也相对容易。

	哈希表也有一些缺点：它是基于数组的，数组创建后难于扩展。某些哈希表被
基本填满时，性能下降的非常严重，所以程序员必须要清楚表中将要存储多少数
据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。
	而且，也没有一种简便的方法可以以任何一种顺序（例如从小到大）遍历表中的
数据项。如果要遍历，就只能选择其他数据结构。
	如果不需要有序遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度
和易用性方面是无与伦比的。


哈希化简介
	哈希表与哈希化是重点。其中一个重要的概念是如何把关键字转换成数组下标。
在哈希表中，这个转换通过哈希函数来完成。然而，对于特定的关键字，并不需要
哈希函数；关键字的值可以直接用于数组下表。若关键字值不能恰好用于数组下标
事，用哈希函数进行转换。

比如员工的编号。有5000个员工，编号为数组索引，从0-5000，这样关键字值恰好
用于数组下标。但是这是属于数据结构组织的非常好的一种情况。

哈希化
	将关键字做一些特殊的数学处理，生成唯一的数字。
	幂的连乘
	在一个大于10的数字中，每一数位代表用数字乘以当前位到个位的位树多个10，
比如7654的意思是：
	7*1000+6*100+5*10+4*1
	或者写成10的幂的连乘
	7*10³ + 6*10²+5*10^1+4*10^0
	类似的把单词分解为字母组合，把字母转化为它们的数字代码，乘以适当的27的
幂（因为有27个可能的字符，包括空格），然后结果相加。这就给出了每个单词对
应的独一无二的数字。
	例如cats转换成数字。首先把数转化成数列，每个数字乘以相应的27的幂，结果相加
	3*27³ + 1*27² + 20*27 + 19*1 和为60337
	
	不幸的是，如果单词较长，整数的范围会非常的大。
	
	现在需要一种压缩方法，把数位幂的连乘系统中得到的巨大的整数范围压缩到
可接受的数组范围中。
	数组的大小是插入数据项的两倍。
	这个转换的Java表达式为
	arrayIndex = hugeNumber % arraySize;
	这就是一种哈希函数。它把一个大范围的数字哈希成一个小范围的数字。这个小
的范围对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就称为哈希表。

冲突
	把巨大的数字空间压缩成较小的数字空间，必然要付出代价，即不能保证，每个
单词都能映射到数组的空白单元。
	假设要在数组中插入单词melioration。通过哈希函数得到了它的数组下标后，发现
那个单元已经有一个单词了（demystify），因为这个单词哈希化后得到的数组下标与
melioration 相同，这种情况称为冲突。
	前面说过，指定的数组大小两倍与需要存储的数据量。因此，可能一半的单元是空
的。当冲突发生时，一个方法是通过系统的方法找到数组的一个空位，并把这个单词填
入而不再用哈希函数得到的数组下标。这个方法叫做开放地址法。例如，如果cats哈希
化的结果是5421,但它的位置已经被parsnip占用，那么可能会考虑把cats放在5422的位置上。
	第二种方法是创建一个存放单词链表的数组，数组内不直接存储单词。这样，当发生
冲突时，行的数据项直接接到这个数据下标所指的链表中。这种方法叫做链地址法。
========================================================================================
========================================================================================
========================================================================================
========================================================================================
开放地址法
	若数据不能直接放在由哈希函数计算出来的数组下标所指的单元时，就要寻找数组的其他
位置。下面有三种方法，它们在找下一个空白单元时使用的方法不同。这三种方法分别是
线性探测、二次探测和再哈希法。

线性探测
	在线性探测中，线性地查找空白单元。如果5421是要插入数据的位置，它已经被占用了，
那么就是用5422，然后5423，以此类推。数组下标一直递增，直到找到空位。这就是线性
探测。因为它沿着数组的下标一步一步顺序地查找空白单元。
	聚集
	当哈希表变得越来越满时，聚集变得越来越严重。这导致产生非常长的探测长度。意味着
存取序列最后的单元会非常耗时。
	数组填得越满，聚集越可能发生。数组有一般数据项时，这通常不是问题，当三分之二
满的时候，情况也不会太坏。然而，如果超过这个界限，随着聚集越来越严重，性能下降也很
严重。因此，设计哈希表的关键是确保它不会超过整个数组容量的一半，最多到三分之二。

扩展数组
	当哈希表变得太满时，一个选择是扩展数组。在Java中只能另外创建一个新的更大的数组，然后
把旧的数组的所有内容插入到新的数组中。哈希函数根据数组大小给定数据项位置。所以，要顺序
遍历数组元素，用insert()方法重新向新数组中插入每个数组。这叫做重新哈希化。
	扩展后的数组容量通常是原来的两倍。实际上，数组容量应该是一个质数。下面是找到新数组容量
的几个例程。
	private int getPrime(int min) // return 1st prime > min
	{
		for (int j = min + 1; true; j++)		// for all j > min
			if (isPrime(j))						// is j prime?
				return j;						// yes, return it
	}
	
	private boolean isPrime(int n)			// is n prime?
	{
		for (int j = 2; (j * j <= n); j++)	// for all j
			if (n % j ==0)					//divides evenly by j?
				return false;					// yes, so not prime
		return true;							// no, so prime
	}
	
二次探测
	在开放地址发的线性探测中会发生聚集。一旦聚集形成，它会变得越来越大。那些哈希化后的落在聚集
范围内的数据项，都要一步一步移动，并且插在聚集的最后，因此使聚集变得更大。聚集越大，它增长得
也越快。
	已填入哈希表的数据项和表长的比率叫做填装因子。
		loadFactor = nItems / arraySize;
	二次探测是防止聚集产生的一种尝试。思想是探测相隔较远的单元，而不是和原始位置相邻的单元。
	
	步骤是步数的平方
	在线性探测中，如果哈希函数计算的原始下标是x，线性探测就是x+1,x+2,x+3,依次类推。而在二次探测中，
探测的过程是x+1,x+4,x+9,x+16,x+25，以此类推。到原始位置的距离是步数的平方。
	
	二次探测的问题
	二次探测消除了在线性探测中产生的聚集问题，这种聚集问题叫做原始聚集。然而，二次探测产生了另外
一种，更细的狙击问题。之所以会发生，是因为所有映射到同一个位置的关键字在寻找空位时，探测的单元
都是一样的。这种现象叫做二次聚集。

再哈希法
	为了消除原始聚集和二次聚集，可以使用另外的一种方法：再哈希法。二次聚集产生的原因是，算法产生的
探测序列步长总是固定的。
	现在需要的一种方法是产生一种依赖关键字的探测序列，而不是每个关键字都一样。那么，不同的关键字即
使映射到相同的数组下标，也可以使用不同的探测序列。
	方法是把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长。对指定的关键字，步长在整个探
测中是不变的，不过不同的关键字使用不同的步长。
	经验说明，第二个哈希函数必须具备如下特点：
	1.和第一个哈希函数不同。
	2.不能输出0（否则，将没有步长；陷入死循环）
	专家们已经发现下面的哈希函数工作得非常好：
	stepSize = constant - (key % constant);
	其中，constant是质数，且小于数组容量。例如，
	stepSize = 5-(key % 5);
	不同的关键字可能映射到相同的数组下标，但是，它们会（很有可能）产生不同的步长。用这个函数，步长的
范围是从1到5.

表的容量是一个质数
	再哈希法要求哈希表的容量是一个质数。
	假设表的容量不是一个质数。例如，假设表长15，有个特定关键字映射到0，步长为5.探测序列是0，5，10，0，
5，10，以此类推，一直循环下去。算法只尝试这三个单元，所以不可能找到某些空白单元，算法最终会导致崩溃。
hashVal += stepSize;	// add the step  比如stepSize = 5
hashVal %= arraySize;	// for wraparound	arraySize = 15
	如果数组的容量是13一个质数，探测序列最终会访问所有单元。即0,5,10,2,7,12,4,9,1,6,11,3一直下去。只要表中
有一个空位，就可以探测到它。用质数作为数组容量使得任何数想整除它都是不可能的，因此探测序列最终会检查所
有单元。

	使用开放地址策略时，探测序列通常用再哈希法生成。
========================================================================================
========================================================================================
========================================================================================
========================================================================================
链地址法
	开放地址法中，通过在哈希表中再寻找一个空位解决冲突问题。另一个方法是在哈希表每个单元中设置链表。某个
数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这
个位置的数据项只需要加入到链表中；不需要在原始的数组中寻找空位。
	装填因子
	链地址法中的装填因子（数据项数和哈希表容量的比值）与开放地址法的不同。在链地址法中，需要在有N个单元
的数组中装入N个或更多的数据项；因此，装填因子一般为1，或比1大。因为，某些位置包含的链表中包含两个或两个
以上的数据项。
	在开放地址法中，当装填因子超过二分之一或三分之二后，性能下降得很快。在链地址法中，装填因子可以达到1以上，
且对性能影响不大。因此，链地址法是更健壮的机制，特别是当事先难以确定哈希表要存储多少数据时更是如此。
	重复值
	这里允许重复，在填入过程中可以填重复出现的值。所有相同关键字值的项都放在同一链表中。所以如果需要找到所有
项，不管查找是否成功，都要搜索整个链表。这会使性能略微下降。
========================================================================================
========================================================================================
========================================================================================
========================================================================================
哈希化字符串
	public static int hashFunc1(String key) 
	{
		int hashVal = 0;
		int pow27 = 1;	// 1, 27, 27*27,etc
		for (int j = key.length() - 1; j >= 0; j--)  // right to left
		{
			int letter = key.charAt(j)-96;		// get char code
			hashVal += pow27 * letter;			//	times power of 27
			pow27 *= 27;							// next power of 27
		}
		
		return hashVal % arraySize;
	}
	循环从单词最右边的字母开始。字母的数字代码放在变量letter中；这个代码依据的是a=1,b=2依次类推空格等于27。
然后乘以27的若干次幂，对于最右端的字母就是0次幂，接着是1次幂，依次类推。
	这个方法不如想象的那么有效。还有一种Horner的数学恒等式取代乘法。（Horner是英国数学家）。
	var4 * n^4 + var3 * n^3 + var2 * n^2 + var1 * n^1 + var0 * n^0
	可以写成下面的形式
	(((var4 * n + var3) * n + var2) * n + var1) * n + var0
	
	public static int hashFunc2(String key) 
	{
		int hashVal = key.charAt(0) - 96;
		for (int j = 1; j < key.length(); j++)
		{
			int letter = key.charAt(j) -96；
			hashVal = hashVal * 27 + letter;
		}
		return hashVal % arraySize;
	}
	
	上面的方法不能处理大于7个字符的字符串。更长的字符串会导致hashVal的值超过int类型的范围。
	public static int hashFunc3(String key) 
	{
		int hashVal = 0;
		for (int j = 0; j < key.length(); j++)
		{
			int letter = key.charAt(j) - 96;
			hashVal = (hashVal * 27 + letter) % arraySize;
		}
		return hashVal;
	}