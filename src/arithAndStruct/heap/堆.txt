优先级队列使用有序数组实现，删除最大数据项的时间复杂度为O(1),但是插入还是需要较长的O(N)时间。
因为要移动数组中平均一半的数据项以插入新 数据项。

堆。堆是一种树，由它实现的优先级队列的插入和删除的时间复杂度都是O(logN)。尽管这样删除的时间变
慢了一些，但是插入的时间快的多了。当速度非常重要，且有很多插入操作时，可以选择堆来实现优先级
队列。

堆的介绍
	堆是有如下特点的二叉树：
	1.它是完全二叉树。也就是说，除了树的最后一层节点不需要是满的，其他的每一层从左到右都完全
是满的。
	2.它常常用一个数组实现。
	3.堆中的每一个节点都满足堆的条件，也就是说每一个节点的关键字都大于（或等于）这个节点的子节点
的关键字。

弱序
	堆和二叉搜索树相比是弱序的，在二叉搜索树中所有节点的左子孙的关键字都小于右子孙的关键字。这说明
在一个二叉搜索树中通过一个简单的算法就可以按序遍历节点。
	在堆中，按序遍历节点是空难的。对于堆来说，只要求沿着从根到叶子的每一条路径，节点都是按降序排列
的。指定节点的左边节点或者右边节点，以及上层节点或者下层节点由于不在同一路径上，它们的关键字可能比
指定节点的关键字或大或小。除了有共享节点的路径，路径之间都是相互独立的。
	由于堆是弱序的，所以一些操作是空单的或者是不可能的。除了不支持遍历以为，也不能在堆上便利地查找
指定关键字。
	不过对于快速移除最大节点的操作以及快速插入新节点的操作，这种顺序已经足够了。这些操作是使用堆作为
优先级队列时所需的全部操作。

移除
移除是指删除关键字最大的节点。这个节点总是根节点，所以移除是很容易的。根在堆数组中的索引是0；
maxNode=heapArray[0];
问题是一旦移除了根节点，树就不再是完全的了；数组里就有了一个空的数据单元。这个‘洞’必须要填上，可以把数
组中所有数据项都向前移动一个单元，但是还有快得多的方法：
	1.移走根。
	2.把最后一个节点移动到根的位置。
	3.一直向下筛选这个节点，直到它在一个大于它的节点一下，小于它的节点之上为止。
	最后一个节点是树最低层的最右端的数据项，它对应于数组中最后一个填入的数据单元。
	heapArray[0] = heapArray[N-1];
	N--;
	移除了根，使数组容量的大小减一。
	
	在被筛目标节点的每个暂时停留的位置上，向下筛选的算法都要检查哪一个子节点更大。然
后目标节点和较大的子节点交换位置。

插入
	插入节点也是很容易的。插入使用向上筛选，而不是向下筛选。节点初始时插入到数组最后一
个空着的单元中，数组容量大小增一。
	heapArray[N] = newNode;
	N++;
	需要向上筛选新节点，直到它在一个大于它的节点之下，在一个小于它的节点之上。
	向上筛选的算法比向下筛选的算法相对简单。因为它不用比较两个子节点的关键字大小。节点只
有一个父节点，目标节点只要和它的父节点换位即可。

堆的Java代码
	用数组表示一颗树的要点。若数组中节点的索引为X，则
	1.他的父节点的下标为（x - 1）/ 2.
	2.他的左子节点的下标为2*x + 1;
	3.他的右子节点的下标为2*x + 2;
	
堆排序
	堆排序的基本思想是使用普通的insert例程在堆中插入全部无序的数据项，然后重复用remove例程，就可
以按序移除所有的数据项。
	for (j = 0; j < size; j++)
		heap.insert(anArray[j]);
	for (j = 0; j < size; j++)
		anArray[j] = heap.remove();
	因为insert和remove方法操作的时间复杂度都是O(logN),并且每个方法必须都要执行N次，所以整个排序操作
需要O(N*logN)时间。这和快速排序一样。但是它不如快速排序快。